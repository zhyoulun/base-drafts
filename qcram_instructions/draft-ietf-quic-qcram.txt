



QUIC                                                           C. Krasic
Internet-Draft                                               Google, Inc
Intended status: Standards Track                               M. Bishop
Expires: September 1, 2018                           Akamai Technologies
                                                        A. Frindell, Ed.
                                                                Facebook
                                                       February 28, 2018


                 Header Compression for HTTP over QUIC
                      draft-ietf-quic-qcram-latest

Abstract

   This specification defines QCRAM, a compression format for
   efficiently representing HTTP header fields, to be used in HTTP over
   QUIC.  This is a variation of HPACK header compression that seeks to
   reduce head-of-line blocking.

Note to Readers

   Discussion of this draft takes place on the QUIC working group
   mailing list (quic@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=quic [1].

   Working Group information can be found at https://github.com/quicwg
   [2]; source code and issues list for this draft can be found at
   https://github.com/quicwg/base-drafts/labels/-qcram [3].

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on September 1, 2018.






Krasic, et al.          Expires September 1, 2018               [Page 1]

Internet-Draft                    QCRAM                    February 2018


Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Head-of-Line Blocking in HPACK  . . . . . . . . . . . . .   3
     1.2.  Avoiding Head-of-Line Blocking in HTTP/QUIC . . . . . . .   4
   2.  Wire Format . . . . . . . . . . . . . . . . . . . . . . . . .   4
     2.1.  Primitives  . . . . . . . . . . . . . . . . . . . . . . .   5
     2.2.  HEADERS Frames on the Control Stream  . . . . . . . . . .   5
       2.2.1.  Insert With Name Reference  . . . . . . . . . . . . .   5
       2.2.2.  Insert Without Name Reference . . . . . . . . . . . .   6
       2.2.3.  Duplicate . . . . . . . . . . . . . . . . . . . . . .   6
       2.2.4.  Dynamic Table Size Update . . . . . . . . . . . . . .   7
     2.3.  HEADER_ACK Frames . . . . . . . . . . . . . . . . . . . .   7
     2.4.  Request Streams . . . . . . . . . . . . . . . . . . . . .   8
       2.4.1.  Index Encoding  . . . . . . . . . . . . . . . . . . .   8
       2.4.2.  Hybrid absolute-relative indexing . . . . . . . . . .   9
       2.4.3.  Instructions  . . . . . . . . . . . . . . . . . . . .  10
   3.  Encoding Strategies . . . . . . . . . . . . . . . . . . . . .  12
     3.1.  Reference Tracking  . . . . . . . . . . . . . . . . . . .  12
       3.1.1.  Blocked Eviction  . . . . . . . . . . . . . . . . . .  12
     3.2.  Blocked Decoding  . . . . . . . . . . . . . . . . . . . .  13
     3.3.  Speculative table updates . . . . . . . . . . . . . . . .  13
       3.3.1.  Fixed overhead. . . . . . . . . . . . . . . . . . . .  13
   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  13
   5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  13
   6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13
     6.1.  Normative References  . . . . . . . . . . . . . . . . . .  14
     6.2.  Informative References  . . . . . . . . . . . . . . . . .  14
     6.3.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  14
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  14
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  15





Krasic, et al.          Expires September 1, 2018               [Page 2]

Internet-Draft                    QCRAM                    February 2018


1.  Introduction

   The QUIC transport protocol was designed from the outset to support
   HTTP semantics, and its design subsumes many of the features of
   HTTP/2.  QUIC's stream multiplexing comes into some conflict with
   header compression.  A key goal of the design of QUIC is to improve
   stream multiplexing relative to HTTP/2 by eliminating HoL (head of
   line) blocking, which can occur in HTTP/2.  HoL blocking can happen
   because all HTTP/2 streams are multiplexed onto a single TCP
   connection with its in-order semantics.  QUIC can maintain
   independence between streams because it implements core transport
   functionality in a fully stream-aware manner.  However, the HTTP/QUIC
   mapping is still subject to HoL blocking if HPACK is used directly.
   HPACK exploits multiplexing for greater compression, shrinking the
   representation of headers that have appeared earlier on the same
   connection.  In the context of QUIC, this imposes a vulnerability to
   HoL blocking (see Section 1.1).

   QUIC is described in [QUIC-TRANSPORT].  The HTTP/QUIC mapping is
   described in [QUIC-HTTP].  For a full description of HTTP/2, see
   [RFC7540].  The description of HPACK is [RFC7541], with important
   terminology in Section 1.3.

   QCRAM modifies HPACK to allow correctness in the presence of out-of-
   order delivery, with flexibility for implementations to balance
   between resilience against HoL blocking and optimal compression
   ratio.  The design goals are to closely approach the compression
   ratio of HPACK with substantially less head-of-line blocking under
   the same loss conditions.

   QCRAM is intended to be a relatively non-intrusive extension to
   HPACK; an implementation should be easily shared within stacks
   supporting both HTTP/2 over (TLS+)TCP and HTTP/QUIC.

1.1.  Head-of-Line Blocking in HPACK

   HPACK enables several types of header representations, one of which
   also adds the header to a dynamic table of header values.  These
   values are then available for reuse in subsequent header blocks
   simply by referencing the entry number in the table.

   If the packet containing a header is lost, that stream cannot
   complete header processing until the packet is retransmitted.  This
   is unavoidable.  However, other streams which rely on the state
   created by that packet _also_ cannot make progress.  This is the
   problem which QUIC solves in general, but which is reintroduced by
   HPACK when the loss includes a HEADERS frame.




Krasic, et al.          Expires September 1, 2018               [Page 3]

Internet-Draft                    QCRAM                    February 2018


1.2.  Avoiding Head-of-Line Blocking in HTTP/QUIC

   In the example above, the second stream contained a reference to data
   which might not yet have been processed by the recipient.  Such
   references are called "vulnerable," because the loss of a different
   packet can keep the reference from being usable.

   The encoder can choose on a per-header-block basis whether to favor
   higher compression ratio (by permitting vulnerable references) or HoL
   resilience (by avoiding them).  This is signaled by the BLOCKING flag
   in HEADERS and PUSH_PROMISE frames (see [QUIC-HTTP]).

   If a header block contains no vulnerable header fields, BLOCKING MUST
   be 0.  This implies that the header fields are represented either as
   references to dynamic table entries which are known to have been
   received, or as Literal header fields (see Section 6.2 of [RFC7541]).

   If a header block contains any header field which references dynamic
   table state which the peer might not have received yet, the BLOCKING
   flag MUST be set.  If the peer does not yet have the appropriate
   state, such blocks might not be processed on arrival.

   The header block contains a prefix (Section 2.4.1).  This prefix
   contains table offset information that establishes total ordering
   among all headers, regardless of reordering in the transport (see
   Section 2.4.2).

   In blocking mode, the prefix additionally identifies the minimum
   state required to process any vulnerable references in the header
   block (see "Depends Index" in Section 2.4.2).  The decoder keeps
   track of which entries have been added to its dynamic table.  The
   stream for a header with BLOCKING flag set is considered blocked by
   the decoder and can not be processed until all entries in the range
   "[1, Depends Index]" have been added.  While blocked, header field
   data MUST remain in the blocked stream's flow control window.

2.  Wire Format

   QCRAM instructions occur on three stream types, each of which uses a
   separate instruction space:

   o  Table updates are carried by HEADERS frames on the control stream,
      as defined by [QUIC-HTTP].  Frames on this stream modify the
      dynamic table state without generating output to any particular
      request.

   o  Acknowledgement of header frame processing is carried by
      HEADER_ACK frames, running from decoder to encoder.



Krasic, et al.          Expires September 1, 2018               [Page 4]

Internet-Draft                    QCRAM                    February 2018


   o  Finally, the contents of HEADERS and PUSH_PROMISE frames on
      request streams reference the QPACK table state.

   This section describes the instructions which are possible on each
   stream type.

   In order to ensure table consistency and simplify update management,
   all table updates occur on the control stream rather than on request
   streams.  Request streams contain only header blocks, which do not
   modify the state of the table.

2.1.  Primitives

   The prefixed integer from Section 5.1 of [RFC7541] is used heavily
   throughout this document.  The string literal, defined by Section 5.2
   of [RFC7541], is used with the following modification.

   HPACK defines string literals to begin on a byte boundary.  They
   begin with a single flag (indicating whether the string is Huffman-
   coded), followed by the Length encoded as a 7-bit prefix integer, and
   finally Length octets of data.

   QCRAM permits strings to begin other than on a byte boundary.  An
   "N-bit prefix string literal" begins with the same Huffman flag,
   followed by the length encoded as an (N-1)-bit prefix integer.  The
   remainder of the string literal is unmodified.

   A string literal without a prefix length noted is an 8-bit prefix
   string literal and follows the definitions in [RFC7541] without
   modification.

2.2.  HEADERS Frames on the Control Stream

   Table updates can add a table entry, possibly using existing entries
   to avoid transmitting redundant information.  The name can be
   transmitted as a reference to an existing entry in either table or as
   a string literal.  For entries which already exist in the dynamic
   table, the full entry can also be used by reference, creating a
   duplicate entry.

2.2.1.  Insert With Name Reference

   An addition to the header table where the header field name matches
   the header field name of an entry stored in the static table or the
   dynamic table starts with the '1' one-bit pattern.  The "S" bit
   indicates whether the reference is to the static (S=1) or dynamic
   (S=0) table.  The header field name is represented using the index of
   that entry, which is represented as an integer with a 6-bit prefix



Krasic, et al.          Expires September 1, 2018               [Page 5]

Internet-Draft                    QCRAM                    February 2018


   (see Section 5.1 of [RFC7541]).  Table indices are always non-zero; a
   zero index MUST be treated as a decoding error.

   The header name reference is followed by the header field value
   represented as a string literal (see Section 5.2 of [RFC7541]).

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 1 | S |    Name Index (6+)    |
      +---+---+-----------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+

                    Insert Header Field -- Indexed Name

2.2.2.  Insert Without Name Reference

   An addition to the header table where both the header field name and
   the header field value are represented as string literals (see
   Section 2.1) starts with the '01' two-bit pattern.

   The name is represented as a 6-bit prefix string literal, while the
   value is represented as an 8-bit prefix string literal.

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 1 | H | Name Length (5+)  |
      +---+---+---+-------------------+
      |  Name String (Length octets)  |
      +---+---------------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+

                      Insert Header Field -- New Name

2.2.3.  Duplicate

   Duplication of an existing entry in the dynamic table starts with the
   '000' three-bit pattern.  The index of the existing entry is
   represented as an integer with a 5-bit prefix.  Table indices are
   always non-zero; a table index of zero MUST be treated as a decoding
   error.





Krasic, et al.          Expires September 1, 2018               [Page 6]

Internet-Draft                    QCRAM                    February 2018


        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 0 | 0 |    Index (5+)     |
      +---+---------------------------+

                            Figure 1: Duplicate

   The existing entry is re-inserted into the dynamic table without
   resending either the name or the value.  This is useful to mitigate
   the eviction of older entries which are frequently referenced, both
   to avoid the need to resend the header and to avoid the entry in the
   table blocking the ability to insert new headers.

2.2.4.  Dynamic Table Size Update

   A dynamic table size update signals a change to the size of the
   dynamic table.

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 0 | 0 | 1 |   Max size (5+)   |
   +---+---------------------------+

                Figure 2: Maximum Dynamic Table Size Change

   A dynamic table size update starts with the '001' 3-bit pattern,
   followed by the new maximum size, represented as an integer with a
   5-bit prefix (see Section 5.1 of [RFC7541]).

   The new maximum size MUST be lower than or equal to the limit
   determined by the protocol using QCRAM.  A value that exceeds this
   limit MUST be treated as a decoding error.  In HTTP/QUIC, this limit
   is the value of the SETTINGS_HEADER_TABLE_SIZE parameter (see
   [QUIC-HTTP]) received from the decoder.

   Reducing the maximum size of the dynamic table can cause entries to
   be evicted (see Section 4.3 of [RFC7541]).

2.3.  HEADER_ACK Frames

   HEADER_ACK frames on the control stream carry information used to
   ensure consistency of the dynamic table.  Information is sent from
   the QCRAM decoder to the QCRAM encoder; that is, the server informs
   the client about the processing of the client's header blocks and
   table updates, and the client informs the server about the processing
   of the server's header blocks and table updates.





Krasic, et al.          Expires September 1, 2018               [Page 7]

Internet-Draft                    QCRAM                    February 2018


   Each frame represents a header block or table update which the QCRAM
   decoder has fully processed.  It is used by the peer's QCRAM encoder
   to determine whether subsequent indexed representations that might
   reference impacted entries are vulnerable to head-of-line blocking,
   and to prevent eviction races.

   The frame payload contains contains a variable-length integer (as
   defined in [QUIC-TRANSPORT]) which indicates the stream on which the
   header block was processed.  The same Stream ID can be identified in
   multiple frames, as multiple header blocks can be sent on a single
   request or push stream.  (Requests can have trailers; responses can
   have intermediate status codes and PUSH_PROMISE frames.)  As the
   control stream carries multiple table updates, the control stream can
   also be identified in multiple frames.

   Since header frames on each stream are received and processed in
   order, this gives the encoder precise feedback on which header blocks
   within a stream have been fully processed.

2.4.  Request Streams

   HEADERS and PUSH_PROMISE frames on request and push streams reference
   the dynamic table in a particular state without modifying it, but
   emit the headers for an HTTP request or response.

2.4.1.  Index Encoding

   Header data is prefixed by an integer: "Base Index".  "Base index" is
   the cumulative number of entries added to the dynamic table prior to
   encoding the current block, including any entries already evicted.
   It is encoded as a single 8-bit prefix integer:

       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |Base Index (8+)|
      +---------------+

                Figure 3: Absolute indexing (BLOCKING=0x0)

   Section 2.4.2 describes the role of "Base Index".

   When the BLOCKING flag is 0x1, a the prefix additionally contains a
   second HPACK integer (8-bit prefix) 'Depends':








Krasic, et al.          Expires September 1, 2018               [Page 8]

Internet-Draft                    QCRAM                    February 2018


       0 1 2 3 4 5 6 7
      +-+-+-+-+-+-+-+-+
      |Base Index (8+)|
      +---------------+
      |Depends    (8+)|
      +---------------+

                Figure 4: Absolute indexing (BLOCKING=0x1)

   Depends is used to identify header dependencies (see Section 1.2).
   The encoder computes a value "Depends Index" which is the largest
   (absolute) index referenced by the following header block.  To help
   keep the prefix smaller, "Depends Index" is converted to a relative
   value: "Depends = Base Index - Depends Index".

2.4.2.  Hybrid absolute-relative indexing

   HPACK indexed entries refer to an entry by its current position in
   the dynamic table.  As Figure 1 of [RFC7541] illustrates, newer
   entries have smaller indices, and older entries are evicted first if
   the table is full.  Under this scheme, each insertion to the table
   causes the index of all existing entries to change (implicitly).
   Implicit index updates are acceptable for HTTP/2 because TCP is
   totally ordered, but are problematic in the out-of-order context of
   QUIC.

   QCRAM uses a hybrid absolute-relative indexing approach.

   When the encoder adds a new entry to its header table, it can compute
   an absolute index:

   "entry.absoluteIndex = baseIndex++; "

   Since literals with indexing are only sent on the control stream, the
   decoder can be guaranteed to compute the same absolute index values
   when it adds corresponding entries to its table, just as in HPACK and
   HTTP/2.

   When encoding indexed representations, the following holds for
   (relative) HPACK indices:

   "relative index = baseIndex - entry.absoluteIndex + staticTable.size"

   Header blocks on request and push streams do not modify the dynamic
   table state, so they never change the "baseIndex".  However, since
   ordering between streams is not guaranteed, the value of "baseIndex"
   can not be synchronized implicitly.  Instead then, QCRAM sends
   encoder's "Base Index" explicitly as part of the prefix (see



Krasic, et al.          Expires September 1, 2018               [Page 9]

Internet-Draft                    QCRAM                    February 2018


   Section 2.4.1), so that the decoder can compute the same absolute
   indices that the encoder used:

   "absoluteIndex = prefix.baseIndex + staticTable.size -
   relativeIndex;"

   In this way, even if request or push stream headers are decoded in a
   different order than encoded, the absolute indices will still
   identify the correct table entries.

   It is an error if the HPACK decoder encounters an indexed
   representation that refers to an entry missing from the table, and
   the connection MUST be closed with the
   "HTTP_HPACK_DECOMPRESSION_FAILED" error code.

2.4.3.  Instructions

2.4.3.1.  Indexed Header Field

   An indexed header field representation identifies an entry in either
   the static table or the dynamic table and causes that header field to
   be added to the decoded header list, as described in Section 3.2 of
   [RFC7541].

     0   1   2   3   4   5   6   7
   +---+---+---+---+---+---+---+---+
   | 1 | S |      Index (6+)       |
   +---+---+-----------------------+

                           Indexed Header Field

   An indexed header field starts with the '1' 1-bit pattern, followed
   by the "S" bit indicating whether the reference is into the static
   (S=1) or dynamic (S=0) table.  Finally, the index of the matching
   header field is represented as an integer with a 6-bit prefix (see
   Section 5.1 of [RFC7541]).

   The index value of 0 is not used.  It MUST be treated as a decoding
   error if found in an indexed header field representation.

2.4.3.2.  Literal Header Field With Name Reference

   A header where the header field name matches the header field name of
   an entry stored in the static table or the dynamic table starts with
   the '00' two-bit pattern.

   The third bit, 'N', indicates whether an intermediary is permitted to
   add this header to the dynamic header table on subsequent hops.  When



Krasic, et al.          Expires September 1, 2018              [Page 10]

Internet-Draft                    QCRAM                    February 2018


   the 'N' bit is set, the encoded header MUST always be encoded with a
   literal representation.  In particular, when a peer sends a header
   field that it received represented as a literal header field with the
   'N' bit set, it MUST use a literal representation to forward this
   header field.  This bit is intended for protecting header field
   values that are not to be put at risk by compressing them (see
   Section 7.1 of [RFC7541] for more details).

   The header field name is represented using the index of that entry,
   which is represented as an integer with a 4-bit prefix (see
   Section 5.1 of [RFC7541]).  The "S" bit indicates whether the
   reference is to the static (S=1) or dynamic (S=0) table.
   Table indices are always non-zero; a zero index MUST be treated as a
   decoding error.

        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 0 | N | S |Name Index (4+)|
      +---+---+-----------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+

                 Literal Header Field With Name Reference

2.4.3.3.  Literal Header Field Without Name Reference

   An addition to the header table where both the header field name and
   the header field value are represented as string literals (see
   Section 2.1) starts with the '01' two-bit pattern.

   The third bit, 'N', indicates whether an intermediary is permitted to
   add this header to the dynamic header table on subsequent hops.  When
   the 'N' bit is set, the encoded header MUST always be encoded with a
   literal representation.  In particular, when a peer sends a header
   field that it received represented as a literal header field with the
   'N' bit set, it MUST use a literal representation to forward this
   header field.  This bit is intended for protecting header field
   values that are not to be put at risk by compressing them (see
   Section 7.1 of [RFC7541] for more details).

   The name is represented as a 5-bit prefix string literal, while the
   value is represented as an 8-bit prefix string literal.







Krasic, et al.          Expires September 1, 2018              [Page 11]

Internet-Draft                    QCRAM                    February 2018


        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 1 | N | H |Name Length(4+)|
      +---+---+---+-------------------+
      |  Name String (Length octets)  |
      +---+---------------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+

                Literal Header Field Without Name Reference

3.  Encoding Strategies

3.1.  Reference Tracking

   An encoder MUST ensure that a header block which references a dynamic
   table entry is not received by the decoder after the referenced entry
   has already been evicted, and MUST ensure that the decoder will not
   suffer head-of-line blocking if the decoder has not opted to receive
   blocking references.  Even if the decoder is willing to process
   blocking references, the encoder might choose to avoid them in
   certain cases.

   In order to enable this, the encoder will need to track outstanding
   (unacknowledged) header blocks and table updates using feedback
   received from the decoder.

3.1.1.  Blocked Eviction

   The encoder MUST NOT permit an entry to be evicted while a reference
   to that entry remains unacknowledged.  If a new header to be inserted
   into the dynamic table would cause the eviction of such an entry, the
   encoder MUST NOT emit the insert instruction until the reference has
   been processed by the decoder and acknowledged.

   The encoder can emit a literal representation for the new header in
   order to avoid encoding delays, and MAY insert the header into the
   table later if desired.

   To ensure that the blocked eviction case is rare, references to the
   oldest entries in the dynamic table SHOULD be avoided.  When one of
   the oldest entries in the table is still actively used for
   references, the encoder SHOULD emit an Indexed-Duplicate
   representation instead (see Section 2.2.3).





Krasic, et al.          Expires September 1, 2018              [Page 12]

Internet-Draft                    QCRAM                    February 2018


3.2.  Blocked Decoding

   For header blocks encoded in non-blocking mode, the encoder needs to
   forego indexed representations that refer to table updates which have
   not yet been acknowledged with Section 2.3.  An implementation could
   extend the header table entry with a boolean to track acknowledgement
   state.  However, the number of entries in the table that are
   unacknowledged is likely to be small in practice, much less than the
   total number of entries, so tracking only un-acknowledged entries
   separate from the main header table might be more space efficient.

   To track blocked streams, the necessary "Depends Index" values for
   each stream can be used.  Whenever the decoder processes a table
   update, it can begin decoding any blocked streams that now have their
   dependencies satisfied.

3.3.  Speculative table updates

   Implementations can _speculatively_ send header frames on the HTTP
   Control Streams which are not needed for any current HTTP request or
   response.  Such headers could be used strategically to improve
   performance.  For instance, the encoder might decide to _refresh_ by
   sending Indexed-Duplicate representations for popular header fields
   (Section 2.4.1), ensuring they have small indices and hence minimal
   size on the wire.

3.3.1.  Fixed overhead.

   HPACK defines overhead as 32 bytes ([RFC7541], Section 4.1).  As
   described above, QCRAM adds some per-connection state, and possibly
   some per-entry state to track acknowledgment status and eviction
   reference count.  A larger value than 32 might be more accurate for
   QCRAM.

4.  Security Considerations

   TBD.

5.  IANA Considerations

   None.

6.  References








Krasic, et al.          Expires September 1, 2018              [Page 13]

Internet-Draft                    QCRAM                    February 2018


6.1.  Normative References

   [QUIC-HTTP]
              Bishop, M., "Hypertext Transfer Protocol (HTTP) over
              QUIC", draft-ietf-quic-http-09 (work in progress), January
              2018.

   [RFC7541]  Peon, R. and H. Ruellan, "HPACK: Header Compression for
              HTTP/2", RFC 7541, DOI 10.17487/RFC7541, May 2015,
              <https://www.rfc-editor.org/info/rfc7541>.

6.2.  Informative References

   [QUIC-TRANSPORT]
              Iyengar, J. and M. Thomson, "QUIC: A UDP-Based Multiplexed
              and Secure Transport", draft-ietf-quic-transport-09 (work
              in progress), January 2018.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015,
              <https://www.rfc-editor.org/info/rfc7540>.

6.3.  URIs

   [1] https://mailarchive.ietf.org/arch/search/?email_list=quic

   [2] https://github.com/quicwg

   [3] https://github.com/quicwg/base-drafts/labels/-qcram

Acknowledgments

   This draft draws heavily on the text of [RFC7541].  The indirect
   input of those authors is gratefully acknowledged, as well as ideas
   from:

   o  Ryan Hamilton

   o  Patrick McManus

   o  Kazuho Oku

   o  Biren Roy

   o  Ian Swett

   o  Dmitri Tikhonov



Krasic, et al.          Expires September 1, 2018              [Page 14]

Internet-Draft                    QCRAM                    February 2018


Authors' Addresses

   Charles 'Buck' Krasic
   Google, Inc

   Email: ckrasic@google.com


   Mike Bishop
   Akamai Technologies

   Email: mbishop@evequefou.be


   Alan Frindell (editor)
   Facebook

   Email: afrind@fb.com

































Krasic, et al.          Expires September 1, 2018              [Page 15]
